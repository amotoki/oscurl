#!/usr/bin/env python

import fileinput
import json
import httplib
import optparse
import os
import logging
import sys
import urlparse
import yaml


logging.basicConfig()
LOG = logging.getLogger('oscurl')


def error_exit(message):
    sys.stdout.flush()
    LOG.error(message)
    sys.exit(1)


def patch_send():
    old_send = httplib.HTTPConnection.send

    def new_send(self, data):
        print('==== HTTP REQUEST ====\n%s\n==== HTTP RESPONSE ====' % data)
        return old_send(self, data)

    httplib.HTTPConnection.send = new_send


def format_response_top(obj):
    version = obj.version
    status = obj.status
    reason = obj.reason
    if version == 9:
        version_str = 'HTTP/0.9'
    elif version == 10:
        version_str = 'HTTP/1.0'
    elif version == 11:
        version_str = 'HTTP/1.1'
    return '%s %d %s' % (version_str, status, reason)


def get_token(service):
    for ev in ['OS_AUTH_URL', 'OS_TENANT_NAME', 'OS_USERNAME', 'OS_PASSWORD']:
        if ev not in os.environ:
            error_exit('%s not set\n' % ev)

    urlobj = urlparse.urlparse(os.environ['OS_AUTH_URL'])
    host = urlobj.hostname
    port = urlobj.port
    base_path = urlobj.path.rstrip('/')
    if urlobj.scheme == 'http':
        conn = httplib.HTTPConnection(host, port)
    elif urlobj.scheme == 'https':
        conn = httplib.HTTPSConnection(host, port)
    else:
        error_exit('Invalid schema in OS_AUTH_URL\n')

    request_body = {
        "auth": {
            "tenantName": os.environ['OS_TENANT_NAME'],
            "passwordCredentials": {
                "username": os.environ['OS_USERNAME'],
                "password": os.environ['OS_PASSWORD']
            }
        }
    }
    request_headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }

    conn.request('POST', base_path + '/tokens',
                 json.dumps(request_body), request_headers)

    response = conn.getresponse()
    if not 200 <= response.status < 300:
        error_exit('HTTP access failed: status=%d %s\n' % (
                   response.status, response.reason))

    response_body = json.loads(response.read())

    for s in response_body['access']['serviceCatalog']:
        if s['name'] == service or s['type'] == service:
            break
    else:
        error_exit('Service %s not found\n' % service)

    public_url = s['endpoints'][0]['publicURL']
    token = response_body['access']['token']['id']

    return (public_url, token)


def do_request(body, **kwargs):
    service = kwargs['service']
    (url, token) = get_token(service)

    urlobj = urlparse.urlparse(url)
    host = urlobj.hostname
    port = urlobj.port
    base_path = urlobj.path.rstrip('/')
    if urlobj.scheme == 'http':
        conn = httplib.HTTPConnection(host, port)
    elif urlobj.scheme == 'https':
        conn = httplib.HTTPSConnection(host, port)
    else:
        error_exit('Invalid scheme in %s\n' % url)

    method = kwargs['method']
    path = base_path + kwargs['path']

    request_headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Auth-Token': token,
    }

    if kwargs.get('fullpath'):
        path = kwargs['fullpath']

    if kwargs.get('debug'):
        conn.set_debuglevel(1)
    elif kwargs.get('dump_request'):
        patch_send()

    conn.request(method, path, body, request_headers)
    response = conn.getresponse()
    if not 200 <= response.status < 300:
        error_exit('HTTP access failed: status=%d %s\n' % (
                   response.status, response.reason))

    format = kwargs['format']
    response_top = format_response_top(response)
    response_headers = response.msg
    response_body_str = response.read()
    if format == 'RAW':
        print(response_top)
        print(response_headers)
        print(response_body_str)
    elif format == 'HEADER':
        print(response_top)
        print(response_headers)
    elif format == 'BODY':
        print(response_body_str)
    elif format == 'YAML':
        print(response_top)
        print(response_headers)
        if not response_body_str:
            return
        response_body = json.loads(response_body_str)
        print(yaml.safe_dump(response_body, encoding='utf-8'))
    elif format == 'JSON':
        print(response_top)
        print(response_headers)
        if not response_body_str:
            return
        response_body = json.loads(response_body_str)
        print(json.dumps(response_body, sort_keys=True, indent=2))

if __name__ == '__main__':

    default_service = os.environ.get('OSCURL_SERVICE', 'compute')
    default_method = os.environ.get('OSCURL_METHOD', 'GET')
    default_format = os.environ.get('OSCURL_FORMAT', 'RAW')

    usage = "usage: %prog [options] [<request_body_file>]"
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-s", "--service", dest="service",
                      help="service name "
                      "(cinder/ec2/glance/keystone/nova/quantum)"
                      " or type "
                      "(volume/ec2/image/identity/compute/network)"
                      ", " +
                           "default=%s" % default_service,
                      metavar="SERVICE",
                      default=default_service)
    parser.add_option("-m", "--method", dest="method",
                      help="request method "
                           "(GET/HEAD/POST/PUT/DELETE), "
                           "default=%s" % default_method,
                      metavar="METHOD", default=default_method)
    parser.add_option("-p", "--path", dest="path",
                      help="differential path of URL", metavar="PATH",
                      default='')
    parser.add_option("-P", "--full-path", dest="fullpath",
                      help="full path of URL", metavar="FULLPATH")
    parser.add_option("-f", "--format", dest="format",
                      help="format of response output "
                           "(RAW/HEADER/BODY/YAML/JSON/NONE), "
                           "default=%s" % default_format,
                      metavar="FORMAT", default=default_format)
    parser.add_option("-d", "--debug",
                      action="store_true", dest="debug",
                      default=False,
                      help="debug mode")
    parser.add_option("-r", "--dump-request",
                      action="store_true", dest="dump_request",
                      default=False,
                      help="dump HTTP request")

    (options, args) = parser.parse_args()

    if not options.method in ['GET', 'HEAD', 'POST', 'PUT', 'DELETE']:
        error_exit('invalid HTTP method %s\n' % options.method)

    if not options.format in ['RAW', 'HEADER', 'BODY', 'YAML', 'JSON', 'NONE']:
        error_exit('invalid output format %s\n' % options.format)

    body = ''
    if args:
        for line in fileinput.input(args):
            body += line.strip()
        json.loads(body)

    do_request(body, **(options.__dict__))
